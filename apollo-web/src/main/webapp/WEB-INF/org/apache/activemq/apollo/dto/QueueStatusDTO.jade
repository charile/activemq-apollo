-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-# 
-# http://www.apache.org/licenses/LICENSE-2.0
-# 
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.

- import it._
- val helper = new org.apache.activemq.apollo.web.resources.ViewHelper
- import helper._

.breadcumbs
  a(href={strip_resolve("..")}) Back

h1 Queue: #{label}

h2 Current Size

p queue size: #{queue_items} messages
p queue size: #{memory(queue_size)}
- if( capacity > 0 )
  p memory used: #{ "%,.2f".format(capacity_used.toFloat*100.0/capacity) }% (#{memory(capacity_used)}/#{memory(capacity)})
- else
  p memory used: #{ "%,.2f".format(0f) }% (#{memory(capacity_used)}/#{memory(capacity)})

h2 Enqueue/Deqeueue Counters

p enqueued: #{enqueue_item_counter} messages (#{memory(enqueue_size_counter)})

p dequeued: #{dequeue_item_counter} messages (#{memory(dequeue_size_counter)})

p nacked: #{nack_item_counter} messages (#{memory(nack_size_counter)})

h2 Swap Status

p loading from the store: #{memory(loading_size)}
p flushing out of memory: #{memory(flushing_size)}
p holding : #{flushed_items} flushed message references

h3 Producers
ul
  - for( x <- producers )
    - x.kind match
      - case "connection" =>
        li.producer
          a(href={ path("../../../../../../connections/"+x.ref) }) #{x.label}
      - case _ =>


h3 Consumers
ul
  - for( consumer <- consumers )
    - import consumer._
    li.consumer
      - if( link !=null )
        a(href={ path("../../../../../../connections/"+link.ref ) }) #{link.label}

      p next message seq: #{position}
      p acquired: #{acquired_count} messages (#{memory(acquired_size)})
      p dispatched: #{total_dispatched_count} messages (#{memory(total_dispatched_size)})
      p acks: #{total_ack_count} messages
      p naks: #{total_nack_count} messages
      p waiting on: #{waiting_on}

- if ( entries.isEmpty )
  h2
    Entries Dump
    a(href={ id+"?entries=true" }) (Show)
- else
  h2
    Entries Dump
    a(href={ id })  (Hide)
  table.queue-entries
    tr
      th State
      th Size
      th consumers, prefetched
      th position:count

    - for( x <- entries )
      tr
        td #{x.state}
        td #{memory(x.size)}
        td #{x.consumer_count}, #{x.is_prefetched}
        td #{x.seq}:#{x.count}

